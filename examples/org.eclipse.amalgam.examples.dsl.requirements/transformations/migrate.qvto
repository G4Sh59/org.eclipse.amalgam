modeltype older 'strict' uses 'http://www.eclipse.org/2008/requirements';
modeltype newer 'strict' uses 'http://www.eclipse.org/2008a/requirements';

transformation migrate(in oldModel : older, out newModel : newer);

main() {
	oldModel.rootObjects()[Model]->map toNew();
}

mapping older::Model::toNew() : newer::Model {
	title := self.title;
	elements += self.groups.map toGroup();
}

mapping older::RequirementGroup::toGroup() : newer::RequirementGroup {
	name := self.name;
	id := self.id;
	description := self.description;
	children += self.children.map toGroup();
	children += self.requirements.map toRequirement();
}

mapping older::Requirement::toRequirement() : newer::Requirement {
	id := self.id;
	name := self.title;
	description := self.description;
	type := self.type.toType();
	children += self.children.map toRequirement();
	priority := self.priority.toPriority();
	author := self.author;
	created := self.created;
	comments += self.comments.map toComment();
	
--  try clone here, rather than invoke a mapping
	version := self.version.clone()->oclAsType(newer::Version)->any(true);
--	version := self.version.map toVersion();

	dependencies += self.dependencies.late resolve(newer::Requirement);
	scenario := self.scenario;
	state := self.state.toState();
	resolution := self.resolution.toResolution();
}

mapping older::Comment::toComment() : newer::Comment {
	subject := self.subject;
	body := self.body;
	author := self.author;
	created := self.created;
	children += self.children.map toComment();
}

mapping older::Version::toVersion() : newer::Version {
	major := self.major;
	minor := self.minor;
	service := self.service;
}

query older::State::toState() : newer::State {
	var state : newer::State := null;
	switch {
	       (self = older::State::NEW) ? state := newer::State::NEW;
	       (self = older::State::REVIEWED) ? state := newer::State::REVIEWED;
	       (self = older::State::APPROVED) ? state := newer::State::APPROVED;
	       (self = older::State::RESOLVED) ? state := newer::State::RESOLVED;
--	       else ? assert fatal (false) with log('State unsupported', self);
	};
	return state;
}

query older::Type::toType() : newer::Type {
	var type : newer::Type := null;
	switch {
	       (self = older::Type::FUNCTIONAL) ? type := newer::Type::FUNCTIONAL;
	       (self = older::Type::NONFUNCTIONAL) ? type := newer::Type::NONFUNCTIONAL;
--	       else ? assert fatal (false) with log('Type unsupported', self);
	};
	return type;
}

query older::Priority::toPriority() : newer::Priority {
	var priority : newer::Priority := null;
	switch {
	       (self = older::Priority::HIGH) ? priority := newer::Priority::HIGH;
	       (self = older::Priority::MEDIUM) ? priority := newer::Priority::MEDIUM;
	       (self = older::Priority::LOW) ? priority := newer::Priority::LOW;
--	       else ? assert fatal (false) with log('Priority unsupported', self);
	};
	return priority;
}

query older::Resolution::toResolution() : newer::Resolution {
	var resolution : newer::Resolution := null;
	switch {
	       (self = older::Resolution::INVALID) ? resolution := newer::Resolution::INVALID;
	       (self = older::Resolution::ACCEPTED) ? resolution := newer::Resolution::ACCEPTED;
	       (self = older::Resolution::IMPLEMENTED) ? resolution := newer::Resolution::IMPLEMENTED;
	       (self = older::Resolution::LATER) ? resolution := newer::Resolution::LATER;
--	       else ? assert fatal (false) with log('Resolution unsupported', self);
	};
	return resolution;
}


